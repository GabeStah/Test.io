<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<h1 id="how-much-regression-testing-is-enough">How Much Regression Testing is Enough?</h1>
<p>By most definitions, the term <code>regression</code> simply means <em>the act of reverting back to a previous state.</em> Extrapolating a bit on this, in the world of software development and software quality assurance, it stands to reason that <code>regression testing</code> means <em>the act of testing previously tested states of software to ensure nothing has broken in the interim</em>. When a piece of software presents a new bug which wasn't present before, but has now appeared following a new change or update, that requires some form of <code>regression testing</code> to duplicate and eventually resolve this issue.</p>
<p>Unfortunately, once proper <code>regression testing</code> practices are in place for any given project, the sheer volume of <code>regression testing</code> that occurs as the size and scope of a project grows can become daunting. It's all too easy for the software quality assurance team to fall into a never-ending chasm of <code>regression testing</code>, where tests are performed on the entire history of bugs that have been discovered up to that point, which is a quantity often in the thousands for larger projects.</p>
<p>In this article, we'll examine a bit more about the practices of proper <code>regression testing</code>, as well as explore how to determine when enough is enough, or when the brakes should be put on your project's <code>regression testing</code> practices a bit.</p>
<h2 id="the-purpose-of-regression-testing">The Purpose of Regression Testing</h2>
<p>In the world of software quality assurance there exists a term known as <code>software regression</code>, which simply refers to a software bug which causes some kind of unintended non-functionality when a change is made to the system, such as a patch or new release. There are three typical categories of <code>software regressions</code>:</p>
<ul>
<li><strong>Local</strong>: When a new bug is located in the same software component that was updated.</li>
<li><strong>Remote</strong>: When a new bug is located in a different software component than the one that was updated.</li>
<li><strong>Unmasked</strong>: When the bug already existed, but had no effect prior to the update.</li>
</ul>
<p>The overall purpose of <code>regression testing</code> is to easily and effectively uncover all possible <code>software regressions</code>, whether they were newly created (<code>local</code> or <code>remote</code>), or previously undiscovered (<code>unmasked</code>).</p>
<p>Furthermore, <code>regression testing</code> comes with a variety of common practices, depending on how thorough and detailed the process needs to be:</p>
<ul>
<li><strong>Retest All</strong>: As the name implies, this method of <code>regression testing</code> is one where the entirety of the system is re-tested. In most cases, the vast majority of this re-testing is performed by automated tools, though often a full retest is simply not feasible for larger systems or as the release count climbs.</li>
<li><strong>Regression Test Selection</strong>: Instead of testing everything, this technique allows the testing team to utilize a representative selection of tests that will approximate testing of the entire system, but with far less required time or overhead.</li>
<li><strong>Test Case Prioritization</strong>: When specific test cases are in place, it is often preferable to prioritize the testing of said test cases, ahead of those which lower priority. Typically it is best to prioritize test cases which will impact both current and future versions of the software.</li>
</ul>
<h2 id="how-much-regression-testing-is-enough-1">How Much Regression Testing is Enough?</h2>
<p>As with nearly every process during the entire software development life cycle of a project, the most precious resource of all is simply <strong>time</strong>. While it may just be a colloquialism at this point to to exasperatedly say, &quot;There's just never enough time in the day,&quot; as lookers-on casually roll their eyes, there's a certain degree of truth to this idea, particularly in the realm of software quality assurance. Even for the simplest of projects, finding enough time to properly test every aspect of the software can be difficult if not impossible in most situations.</p>
<p>For example, imagine you were performing tests on a very simple application called <code>Addr</code> (which omits the letter <code>e</code> to be hip, of course). This application simply consists of two text boxes and asks the user to input any two numbers, at which point <code>Addr</code> will magically add the numbers together and output the result. Incredible!</p>
<p>Let's also assume each text box can hold a number no larger than 20 characters in size. This means the user can enter any two numbers up to a maximum value of about 99 quintillion (or 10<sup>20</sup>-1) to be added together. The question then becomes, how does the software quality assurance department properly test this very simple application?</p>
<p>The primary issue here is: Are there any values that can be entered into the boxes that cause a failure or produce a bug of some kind? In most cases, developers will have placed constraints on the input boxes to prevent non-numeric text from being entered, as well as numbers that are larger than the 20-character limit, and so forth. Even so, testing for those special cases is fairly quick and easy. The real problem comes in identifying which of the trillions of possible number entries might cause an issue.</p>
<p>The first most obvious answer is to use automated testing, which is very common in <code>regression testing</code> as well, and would allow the computer itself to enter all the possible numbers in both boxes and compare output to the expected result, as well as identify any potential bugs. <a href="https://computers-are-fast.github.io/"><code>Computers are very fast</code></a>, so depending on the testing suite in use, the system it runs on, and so forth, it is likely the computer is capable of testing some <code>five hundred million</code> possible combinations <strong>every second</strong>.</p>
<p>Unfortunately, even at that blazingly fast speed of automated testing, it would still take about <code>6,338 years</code> for a computer to test every combination. We could also arguably reduce our testing time in half, since we're using two possible entry boxes but likely only need to care about testing each unique pair of numbers one time, so we could split our potential combinations entirely in half, but that still requires about <code>three thousand years</code>. Maybe we can somehow afford to use the services of a huge cloud computing platform to perform our testing calculations, but spreading across even a <strong>thousand machines</strong> means we're still looking at a solid three years of testing.</p>
<p>Now to make things really crazy, imagine we <em>did</em> perform this full test, and everything was successful, but suddenly version 1.1 of <code>Addr</code> was released, and it's time for <code>regression testing</code>. Can we assume the functionality still works properly, or do we need to perform our testing once again to ensure nothing was broken during the update?</p>
<p>While this example is for a very simple project, it illustrates just how daunting it can be to find enough time to properly perform adequate regression testing, even on the simplest projects. In most cases -- and certainly so in this example of the near-pointless <code>Addr</code> application -- the best solution is to use a <code>partitioning strategy</code> to help manage the proper balance of <code>regression testing</code>.</p>
<p><code>Partitioning strategies</code> are simply means for software quality assurance engineers to take a <strong>representative sample</strong> of all possibilities for a problem or test, and make the logical assumption that the results from this sample are characteristic of the entire set as whole.</p>
<p>With a <code>partitioning strategy</code> in place for the <code>Addr</code> application, we know what the maximum possible number is, so we might have the testing suite grab a two completely random numbers from the set of possibilities and add them together and test the results. We can do this a ridiculous number of times, as even performing this test with a set of <code>100 billion random pairs of numbers</code>, we'd still only need a little over three minutes to run the automated test. Granted, this would leave a huge number of possible numbers outside the scope of our test, but it strikes a nice balance when performing <code>regression testing</code> that is often necessary to ensure a good mixture of speed and thoroughness.</p>
<hr />
<p><strong>SOURCES</strong></p>
<ul>
<li>https://en.wikipedia.org/wiki/Regression_testing</li>
<li>https://en.wikipedia.org/wiki/Software_regression</li>
<li>https://computers-are-fast.github.io/</li>
</ul>
</body>
</html>
